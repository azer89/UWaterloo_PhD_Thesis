
%\newcommand{\simforce}[1]{\bm{F}_{\kern -0.02in #1}}
\newcommand{\simforce}[1]{\bm{F}_\mathrm{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter[RepulsionPak: Deformation-Driven Element Packing \newline with Repulsion Forces]
{RepulsionPak: Deformation-Driven Element Packing with Repulsion Forces}
\label{chapter_repulsionpak}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[h!]
  \centering
  \includegraphics[width=1.0\textwidth]{figures/repulsionpak/cat_whale_04}
  \caption[A packing of a cat]
  {
  \label{cat_packing}
  		   \newtext{
           (a) A packing of six cat elements inside a fish-shaped target container. 
           (b) Input elements.
           (c) lined up deformed elements in the packing.}
           Controllable deformation and repulsion forces allow the elements to deform,
           efficiently filling the container and creating a uniform distribution of
           negative space. We then reduce the remaining negative space by placing smaller
           cat heads. The gradient fill was added as a post-process.}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{repulsionpak_introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newtext
{
RepulsionPak is a technique
to pack elements using a physical simulation, 
in which each element is represented
by a mass-spring system called an \textit{element mesh}.  
\textit{Repulsion forces} between neighboring meshes work to even out the negative
space, inducing displacements in mesh springs.
These displacements translate, rotate, and deform the elements as 
they gradually adapt to the shapes of their neighbors
and the container boundary.  
To control the amount of deformation,
we use \textit{spring forces} within a mesh to preserve element shapes.}

\newtext{Most of the elements in a packing are large shapes of real-world objects like animals,
plants, or man-made objects.  We refer to these as \textit{primary elements}.
An artist distributes primary elements so that they communicate
the shape of the container, while attempting as much as possible to ensure
an even distribution of negative space.
When the primary elements leave behind large
pockets of negative space, the artist typically fills those pockets with
small \textit{secondary elements}, often simple abstract shapes like 
circles or triangles.
A packing example with primary and secondary elements is shown in Figure~\ref{fig_primary_secondary}.
}

\newtext
{
Unlike FLOWPAK that is optimized to deform long thin elements, 
we design RepulsionPak to support arbitrary shaped elements.
RepulsionPak is also intended to fulfill three of five design principles:
balance, uniformity amidst variety, and boundaries (Section~\ref{flowpak_introduction}). 
We achieve a more even distribution of negative space by building an algorithm with a controllable deformation model at its core. 
We are able to use repeated copies taken from a small library of elements 
but their final shapes are varied thanks to element deformation.
We also show that by carefully placing elements in the initial distribution using a shape matching algorithm, 
the shape of the container boundary can be more emphasized.
%we can emphasize the shape of the container boundary better.
}



%\newtext
%{
%By building an algorithm with a controllable deformation model at its core, we achieve a
%more even distribution of negative space, even with a small library
%of element shapes. We argue that the aesthetic quality
%of the packing as a whole more than compensates for the relatively
%small deformations applied to the elements.
%}

%\newtext
%{
%RepulsionPak can be categorized as a variant of Lloyd's method that distributes
%2D points. To allow RepulsionPak to pack elements and treat them as deformable shapes, we made key differences are: (1) We spread vertices but they are binded together by elastic spring,
%forming 2D elements. (2) We use repulsion forces to distribute these vertices and we do not compute
%a Voronoi diagram.
%}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
\label{repulsionpak_previous_work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newtext
{
\textbf{Lloyd's Method:}
Variants of Lloyd's method have been proposed by
Hausner~\cite{Hausner2001}, Hiller et al.~\cite{Hiller2003}, 
Smith et al.~\cite{Smith2005}, and Dalal et al.~\cite{Dalal2006}.
Although these approaches can generate appealing results, they can only accept
convex or near convex elements. 
RepulsionPak can be categorized as a variant of point-based Lloyd's method without explicitly computing a Voronoi diagram.
Forces do not act directly onto elements, but their mesh vertices.
During the simulation, these mesh vertices are spread apart but still connected using elastic springs,
effectively creating an element representation that can be packed and deformed.
Additionally, unlike previous methods, 
repulsion forces can automatically rotate elements so that neighboring element alignments can be improved. 
}


%\begin{figure}
%\centering
%\includegraphics[width=1.0\textwidth]{figures/repulsionpak/primary_secondary.pdf}
%\caption[Primary and secondary elements]{
%  \label{fig_primary_secondary}
%  \newtext
%  {
%  A packing created by Balabolka.
%  (a) The packing with primary elements only. \newline
%  (b) Secondary elements are added.
%  }
%}
%\end{figure}


\newtext
{
\textbf{Data-driven Methods:}
Data-driven methods include Image Mosaics (JIM)~\cite{Kim2002}, 
the Pyramid of Arclength Descriptor (PAD)~\cite{Kwan2016}.
JIM is able to pack nearly-convex elements tightly by placing one element at a time and
backtracking as needed.  As a shape descriptor, 
PAD can find new elements that partially match
existing element boundaries as a container was being filled.  Both
methods permit some elements to overlap.  While they can
both correct gaps and overlaps using deformation, the deformation
is applied locally near edges in a post-processing step after
elements were frozen in place. 
2D {Arcimboldo} Collage~\cite{Huang2011} and 3D {Arcimboldo} Collage~\cite{Gal2007B}
are also data-driven, but they permit large overlaps to 
resemble the aesthetic style of Arcimboldo's artwork. 
}


\textbf{Deformation-Driven Methods:}
\newtext
{
Xu and Kaplan~\cite{Xu2007} and Zou et al.~\cite{Zou2016}
deformed letters of one or two words to fit into a container.
Because the order of the letterforms was defined by the text, their solutions
require significant distortion of the individual letters.
Peng et al.~\cite{Peng2014} computed layouts by packing and deforming
simple polygons and polyominoes. Their method cannot handle more
complicated shapes, making it unsuitable for our style of packings.
}

\newtext
{
Zehnder et al.~\cite{Zehnder2016} proposed a method to
cover 3D surfaces with deformed ornamental elastic curves.
Our method has some similarities to theirs in that both start with 
scaled-down copies of elements and grow them, but the growth process is quite different.  
Unlike their approach, our elements exert
forces on each other throughout the growth process, allowing them a greater
opportunity to translate, rotate, and deform in search of more even negative
space.  Furthermore, the goal of their work (3D fabrication) is quite 
different from ours (2D ornamentation) and our results appear qualitatively
different.
}



%FLOWPAK (Chapter~\ref{flowpak_chapter}) placed ornamental
%elements to create a visual sense of flow. They used
%skeletal strokes to place elements along streamlines defined from a
%vector field.  However, their elements could not undergo more general
%deformations, and their method did not explicitly control for the evenness
%of the negative space.



\newtext
{
\textbf{Physically-Based Methods for Deformable Objects:}
Contemporary research has yielded many more sophisticated physical simulation methods.
the Finite Element Method (FEM) is accurate and realistic but notoriously slow.
Position Based Dynamics (PBD)~\cite{Muller2007} is simple, robust, and efficient to be used in
real-time applications, but suffers from inaccuracy.
More recently, Projective Dynamics~\cite{Bouaziz2014} bridges a gap between FEM and PBD.
Projective dynamics uses a variational implicit time integration and optimize by
alternating a local constraint step and a global solve step.
}

\newtext
{
\textbf{Sample-Based Representation:}
A few of texture synthesis methods represent an element as a collection of sparse points~\cite{Ma2011, Ma2013, Hsu2020}.
This representation allows them to synthesize textures with elements
that have large concave shapes.
Our RepulsionPak has a similar approach, but we represent an element
with denser vertices that are connected with elastic springs.
}

\newtext
{
\textbf{Curve Simulations:} Pedersen and
Singh~\cite{Pedersen2006} grew curves to create organic
labyrinthine paths. Their algorithm is related to ours by the use
of repulsion forces to maintain even spacing and parallel segments.
More recently, Yu et al.~\cite{Yu2020} used tangent-point energy
to pack curves inside a container while avoiding self-intersections.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Overview}
\label{repulsionpak_system_overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{figure}[t]
\vspace{-30pt}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/pipeline.pdf} 
\caption[RepulsionPak pipeline]
{\label{fig_repulsionpak_pipeline} 
The creation of a packing using RepulsionPak.
  (a) A library of elements, comprising nine primary elements and a single
  	secondary element.
  (b) A target container with the initial distribution of scaled-down elements.
  (c) The simulation in progress, showing the elements growing, translating,
  	rotating, and deforming.
  (d) The resulting packing of primary elements.
  (e) The final result, after adding secondary elements and allowing them to
  	grow.
  	Figure~\ref{fig_defviz} shows the deformations of some of the elements. }
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/pipeline_defviz_csk.pdf}
\caption[Element deformation]{
	\label{fig_defviz}
	Some of the elements in the final packing in Figure~\ref{fig_repulsionpak_pipeline}, 
	showing the effect of deformation in our simulation.
}
\end{figure}

Our system requires three main pieces of input:
\begin{itemize}
	\item A library of primary and optional secondary elements, such
		as those shown in Figure~\ref{fig_repulsionpak_pipeline}a.
	      Each element is a collection of 
		  open or closed polygonal paths---any curves must
		  be flattened ahead of time.
	\item One or more closed polygonal target containers, such as the
		heart in Figure~\ref{fig_repulsionpak_pipeline}b.  Target containers can optionally
		have internal holes.
	\item The desired element spacing distance $d_\mathrm{gap}>0$.
\end{itemize}

RepulsionPak starts by preprocessing the elements, creating additional space around
each to enforce the spacing distance, and fitting a triangle mesh over each element.
The containers are then seeded with randomly placed
copies of scaled-down elements 
(Section~\ref{repulsionpak_preprocessing}).

RepulsionPak then performs a physics simulation on the meshes, 
making them simultaneously grow and repel each other. As a
proof of concept, we implement a spring-based 
simulation, which yields satisfactory results despite its simplicity;
many alternatives are possible 
(see Section~\ref{repulsionpak_conclusions}).
Forces in the simulation push mesh vertices away from vertices in other meshes,
attempt to keep the meshes from undergoing excessive deformation, and resolve
places where meshes overlap or vertices move outside target containers
(Section~\ref{repulsionpak_simulation}).
After each iteration of the simulation, meshes grow into adjacent space
if possible, so that they gradually consume the negative space in the container.

The simulation concludes 
either when the elements occupy a sufficient proportion of the container area, or 
when some number of simulation steps fail to
significantly reduce the negative space
(Section~\ref{repulsionpak_stopping_criteria}).

An optional second simulation further reduces and evens out the
negative space.  It begins by placing small secondary elements in large
pockets of negative space.  This simulation is the same as the
first, except that vertices of primary element meshes are not allowed to move
(Section~\ref{repulsionpak_secondary_elements}).

Final SVG output is created by using barycentric coordinates to map each element's
paths from the element's initial mesh into the deformed mesh produced through
simulation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preprocessing}
\label{repulsionpak_preprocessing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t] %%% ELEMENT IMAGE
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/element_skin_triangles_2.pdf}
\caption[Element discretization]{
	\label{fig_elements_image}
	An illustration of element discretization for preprocessing.
	(a) An element with its boundary displaced to create a skin, drawn in red.
	(b) A triangle mesh with boundary vertices on the skin.
}
\end{figure}




The \textit{skin} of an element is a simple closed polygon 
that fully encloses it, 
as in the red shape in Figure~\ref{fig_elements_image}(a).
We generate the skin 
by offsetting 
an element's boundary outward by $d_\mathrm{gap}/2$. 
The simulation aims to produce an approximate tessellation of the target
container by \newtext{deformed} skins, thereby achieving the desired element spacing and
suppressing overlaps.

We triangulate the element skin to obtain a triangle mesh.
To create the mesh we uniformly sample the skin polygon $s$, with samples
spaced apart by distance $d_\mathrm{gap}$,
to obtain a simpler polygon $s'$ (the outer boundary of the mesh).
We then construct a Delaunay triangulation of $s'$.
The vertices and edges of this mesh become unit 
masses and longitudinal
springs in a physical simulation, allowing elements to deform in response to
their neighbors.  
%We further brace the mesh against
%deformation by augmenting it with ``auxiliary springs'' (see
%Section~\ref{section_forces} and Figure~\ref{fig_forces}b).
%\mynote{this is perfect place to describe negative space springs}
\newtext{
We also add extra edges to prevent
folding and self-intersections during simulation
(Figure~\ref{fig_forces}b).  First, if two triangles 
$ABC$ and $BCD$ share an edge $BC$, then we add a \textit{shear edge}
connecting $A$ and $D$. 
Second, we triangulate the negative space
inside the convex hull of the original Delaunay triangulation, and
create new \textit{negative space edges} corresponding to the newly 
created triangulation edges. 
These negative space edges are used exclusively for internal
bracing.  The element's concavities can still be occupied by its
neighbors.
The construction of negative space edges is a simpler variant of
Air Meshes~\cite{Muller2015}, a technique to detect and resolve collisions.}

Due to discretization, a low mesh resolution does not guarantee a separation of $d_\mathrm{gap}$. 
Increasing the mesh resolution produces a more precise result at the expense of greater running time.

\textbf{Barycentric Coordinates:}
The simulation operates on meshes, not element geometry.  In the final
rendering phase, we will redraw an element relative to a deformed copy of
its mesh.  To do so, we first re-express every vertex of an element path in 
terms of the mesh triangles.  Every element vertex lies either inside a mesh
triangle or just beyond a border edge.  We encode each vertex in barycentric
coordinates relative to its enclosing or nearest triangle.

\textbf{Initial Element Placement:}
We prepare our simulation by randomly placing non-overlapping elements.
\begin{enumerate}
	\item Generate random points \newtext{$P = \{ \bm{p}_1, \bm{p}_2,..., \bm{p}_n \}$ }
		  inside the target container 
	      via blue noise sampling~\cite{Bridson2007}.
	      The user controls the number of points; using more points gives results
	      with smaller elements.  We can automatically estimate $n$ by
		  dividing the container area by the desired average area of the element skins.
	\item Cycle through the primary elements, assigning each element to a 
		  random unused $p_i$ with a random orientation, repeating until 
		  every point has an element.
	\item Shrink all the elements so that they do not overlap and occupy only
		  a small fraction of the container's area; in our implementation we
		  have found that $5-10$\% of the area gives good results. Making them
		  larger would speed up the simulation but does
	      not allow enough freedom of movement to generate successful
		  packings.  Figure~\ref{fig_repulsionpak_pipeline}b shows an initial placement.	      
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulation}
\label{repulsionpak_simulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{Forces}
%\label{repulsionpak_forces}

\newtext
{
We design a simulation in which we generate 
forces that pack and deform elements by transforming their meshes.
Let $\bm{x} = (x, y)$ be a vertex of an element mesh. 
The total force $\simforce{total}$ applied to $\bm{x}$ is
\begin{equation}
\simforce{total} = \simforce{rpl} + \simforce{edg} + \simforce{bdr} + \simforce{ovr} + \simforce{tor}
\end{equation}
where 
\begin{packeddescriptions}
	\item[$\simforce{rpl}$] is the repulsion force;
	\item[$\simforce{edg}$] is the edge force;
	\item[$\simforce{bdr}$] is the boundary force;
	\item[$\simforce{ovr}$] is the overlap force; and
	\item[$\simforce{tor}$] is the torsional force.	
\end{packeddescriptions}
%where $\simforce{rpl}$, $\simforce{edg}$, $\simforce{bdr}$, $\simforce{ovr}$ and $\simforce{tor}$ are 
%the repulsion force, the edge force, the boundary force, the overlap force, and the torsional force.
These forces combine with the growth process, described in
Section~\ref{repulsionpak_element_growth}, to completely fill the target container.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% REPULSION FORCE %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% CSK TODO: what counts as a "nearest neighbouring mesh" in this context?
%% How do we know which neighbours to iterate over?

\medskip
\textbf{Repulsion Force:} 
The repulsion force tries to push element meshes apart when they approach
each other, with the goal of
making them transform to align their boundaries (Figure~\ref{fig_forces}a).
 
The vertex $\bm{x}$ will
experience an inverse square repulsive force, inspired by Coulomb's law,
from all nearby meshes.  We use the following formula:

\begin{equation}
\simforce{rpl} = k_\mathrm{rpl} \sum_{i = 1}^{n} \frac{\bm{u}}{\| \bm{u} \| }\frac{1}{\varsigma  +\| \bm{u} \|^2 }
\end{equation}
where 
\begin{packeddescriptions}
	\item[$k_\mathrm{rpl}$]        is the strength of the repulsion force relative to
						other forces in the simulation;
	\item[$n$]        is the number of nearest neighboring meshes to $\bm{x}$; 
	\item[$\bm{x_{i}}$] is the closest point on the skin of the $i$th neighbor;
	\item[$\bm{u}$]  $= \bm{x} - \bm{x_{i}}$; and
	
						% mesh from $\bm{x}$.		
	
	\item[$\varsigma$]   is a \textit{soft parameter}; it places an upper 
						bound on the magnitude of $\simforce{rpl}$, avoiding
						explosive instability when $\| \bm{u} \|$ is very small.
\end{packeddescriptions}

An imbalance in the repulsion forces across a mesh's vertices will
naturally induce translation and rotation in meshes, helping their
boundaries discover compatible segments and consuming more of the
remaining negative space.

If $\bm{x}$ lies inside of another element's mesh, then the aggregate repulsion
force from other neighbors can push $\bm{x}$ further inside and
worsen the overlap.  If we discover such an overlap, we set
$\simforce{rpl}$ to $0$ and use the overlap force $\simforce{ovr}$, discussed below, to
correct it.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% EDGE FORCE %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\medskip
\textbf{Edge Force:} 
\newtext{
A mesh's edges are treated as longitudinal \textit{springs};
displacements of these springs allow a mesh to deform in response to repulsion forces
by neighboring meshes.
An undeformed element mesh provides the rest lengths for all of
its springs; as mesh vertices move relative to each other, the springs
attempt to restore these rest lengths.  Let $\bm{x_{a}}$ and $\bm{x_{b}}$ be
mesh vertices connected by a spring.  We compute the spring force as follows:
}
\begin{equation}
\label{eq_edge_force}
\simforce{edg} =  k_\mathrm{edg} \frac{\bm{u}}{\| \bm{u} \|} s \; ( \| \bm{u} \| - \ell)^2
\end{equation}
where
\begin{packeddescriptions}
	\item[$k_\mathrm{edg}$] is the strength of the edge force relative to other forces;
	\item[$\bm{u}$] $= \bm{x_{b}} - \bm{x_{a}}$;
	\item[$\ell$] is the rest length of the spring; and
	\item[$s$] is +1 or -1, according to whether $(\| \bm{u} \| - \ell)$ 
		is positive or negative.
\end{packeddescriptions}

We apply $\simforce{edg}$ to $\bm{x_{a}}$ and $-\simforce{edg}$ to $\bm{x_{b}}$.
The equation is a modification of Hooke's law
in which the strength of the force increases quadratically
with displacement.
This change allows the meshes to resist severe deformations
when subjected to powerful forces.

% \paul{Also needed: Why two kinds of springs?  Why are edge springs not enough?
% Why do you call it a bending spring?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% OVERLAP FORCE %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% CSK TODO: verify that "centroid" is the right word here.

\medskip
\textbf{Overlap Force:}
Occasionally, a vertex $\bm{x}$ from one mesh can be pushed inside the skin of a
neighboring mesh.  In such cases, we temporarily disable the repulsion force
on this vertex
by setting it to 0, and instead apply an overlap force that attempts to
eject the intruding vertex.  In particular, every mesh triangle having $\bm{x}$
as a vertex will pull $\bm{x}$ in the direction of its centroid.  The overlap
force is thus given by:

\begin{equation}
\simforce{ovr} = k_\mathrm{ovr} \sum_{i = 1}^{n} (\bm{p_{i}} - \bm{x})
\end{equation}
where
\begin{packeddescriptions}
	\item[$k_\mathrm{ovr}$] is the relative strength of the overlap force;
	\item[$n$] is the number of mesh triangles that have $\bm{x}$ as a vertex; and
	\item[$\bm{p_{i}}$] is the centroid of the $i$th triangle incident on $\bm{x}$.
\end{packeddescriptions}

The overlap force is zero for vertices that are not within another mesh.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% BOUNDARY FORCE %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\medskip
\textbf{Boundary Force:}
The boundary force causes element meshes to stay inside the target container
and conform to its boundary. It applies to any vertex $\bm{x}$ that
is outside the container, and moves the vertex towards the closest point
on the container's boundary, by an amount proportional to the distance to
the boundary:
%%% EQ
\begin{equation}
\simforce{bdr} = k_\mathrm{bdr} (\bm{p_b} - \bm{x})
\end{equation}
where
\begin{packeddescriptions}
	\item[$k_\mathrm{bdr}$] is the relative strength of the boundary force; and
	\item[$\bm{p_b}$] is the closest point on the target container to $\bm{x}$.
\end{packeddescriptions}

The boundary force is zero for any point inside the container.

\medskip
\textbf{Torsional Force:} 
As forces propagate through an element mesh, the aggregate velocity
vectors of the vertices can induce a rotation of the entire element.
However, some elements may have a preferred orientation,
either for aesthetic reasons or because the shape is comprehensible only at certain orientations.
We introduce a torsional force that
penalizes individual vertices for which the orientation, relative to their
element's center of mass, drifts too far from its initial orientation.

Consider a vertex $\bm{x}$ belonging
to an element, and let $\bm{c}_r$ be the element's center of mass in
its undeformed state.  We may define the ``rest orientation'' of
$\bm{x}$ as the orientation of the vector $\bm{u}_r = \bm{x}-\bm{c}_r$.
During simulation we compute the current center of mass $\bm{c}$ of 
the element and let $\bm{u}=\bm{x}-\bm{c}$.  Then the torsional force
is

\begin{equation}
  \simforce{tor} =\begin{cases}
    k_\mathrm{tor}\bm{u}^\perp, & \theta > 0\\
    -k_\mathrm{tor}\bm{u}^\perp, & \theta < 0
  \end{cases}
\end{equation}
where
\begin{packeddescriptions}
	\item[$k_\mathrm{tor}$]  is the relative strength of the torsional force;
	\item[$\theta$] is the signed angle between $\bm{u}_r$ and $\bm{u}$; and
	\item[$\bm{u}^\perp$] is a unit vector rotated $90^\circ$
		counterclockwise relative to $\bm{u}$;
\end{packeddescriptions}

Using the equation above, $\simforce{tor}$ is always perpendicular to $\bm{u}$
and the direction of $\simforce{tor}$ points to the left or to the right depending on $\theta$.
Unlike the first four force types, the torsional force is optional.

\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/all_forces_new.pdf}
\vspace{10pt}
\caption[Illustrations of the forces in a RepulsionPak simulation]{
\label{fig_forces}
Illustrations of the forces in our simulation.
\;\textbf{(a)~Repulsion force}:
The closest point on the snake's mesh
repels a vertex $\bm{x}$ in the bird mesh.
\textbf{(b)~Edge force}: 
We generate edge forces using
\newtext{edge springs (black), shear springs (red), and negative-space springs (dashed blue).}
\textbf{(c)~Overlap force}: 
Centers of triangles $\bm{p_1}$ and $\bm{p_2}$ attract a vertex
$\bm{x}$ that lies in the interior of another mesh.
\;\textbf{(d)~Boundary force}: A vertex $\bm{x}$ moves toward $\bm{p_b}$,
the closest point on a target container, when it is outside the container.
\textbf{(e)~Torsional force}: We restrict the orientation of the element by generating 
a torsional force at every boundary vertex $\bm{x}$
to restore its angular position relative to $\bm{c}$, 
the center of mass of the element.
}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% THE SIMULATION %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\medskip
\textbf{Simulation Details:} 
We use explicit Euler integration to simulate the motions of the mesh vertices under the
forces described above.  Every vertex has a position and a velocity vector; in
every iteration, we update velocities using forces, and update positions using
velocities.  These updates are scaled by \newtext{a simulation time step $\Delta t_\mathrm{sim}$}, typically
chosen from the range $[0.01,0.1]$.  A smaller time step results in a more
stable simulation at the cost of additional running time.  We cap velocities
at \newtext{$5\Delta t_\mathrm{sim}$} to dissipate extra energy from the system.

%% CSK TODO: verify these measurements.

The repulsion and overlap forces rely on nearest-neighbor queries on the
set of all vertices.  We accelerate these queries by storing vertices in a
uniform spatial subdivision grid that covers the container.  In our
implementation, cell width and height are $6-10$\% of the larger dimension
of the grid.  
%\deadtext{We identify the neighbours of a vertex $\bm{x}$ by considering}
We define the neighbors of a vertex $\bm{x}$ as
all vertices in a $3\times 3$ window of cells \newtext{centered} on the cell
containing $\bm{x}$. 
%\deadtext{Although this is an approximation, since it can miss 
%distant vertices in the composition, the effect is insignificant because of the
%low magnitude of forces involving these vertices.}
This approximation ignores the negligible interactions between
distant vertices.

\newtext{
The constants $k_\mathrm{rpl}$, $k_\mathrm{ovr}$, $k_\mathrm{bdr}$  $k_\mathrm{edg}$, and $k_\mathrm{tor}$ 
control the relative strengths
of the five forces in the simulation.  They must also be chosen relative to
the time step $\Delta t_\mathrm{sim}$ and the overall width and height of the container.
We find that our simulation produces satisfactory results when 
$k_\mathrm{rpl} \approx k_\mathrm{ovr} \approx k_\mathrm{bdr} \geq k_\mathrm{edg} > k_\mathrm{tor}$.
For example, if the container's bounding box is approximately $1000\times 1000$,
we set $k_\mathrm{rpl}=k_\mathrm{ovr}=k_\mathrm{bdr}=80$, and $k_\mathrm{tor}=1$.
We set $k_\mathrm{edg} = 40$ for edge springs and shear springs,
and $k_\mathrm{edg} = 10$ for negative-space springs,
since weaker negative-space springs are sufficient to avoid self-intersections.
We also set $\varsigma=1$ to avoid explosive repulsion forces. 
Increasing $k_\mathrm{edg}$
relative to the other forces suppresses deformation, yielding a close approximation
of packing with rigid elements.
} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Element Growth}
\label{repulsionpak_element_growth}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

RepulsionPak starts with small initial elements to avoid intersections,
and gradually enlarges them until they tightly fill the target
container.  Figure~\ref{fig_repulsionpak_pipeline}c-d shows elements growing and gradually
consuming negative space.  Elements have different intrinsic sizes, which are
respected in the initial placement.  Because they all grow at roughly the
same rate, their relative sizes tend to be maintained.

After each iteration of the physics simulation, the element meshes undergo
a growth step.  If an element mesh has no vertices that lie inside of
neighboring meshes, it is permitted to grow in this iteration.  A mesh with
overlaps may still grow in subsequent iterations, if local changes to the 
packing open up more negative space.
This approach produces slight variations in skin offsets in the output packing
but the effect is negligible.

We implement growth in the context of the physics simulation by scaling
the rest lengths of a mesh's springs, allowing it to expand as the simulation
progresses.  Every mesh $M$ has a counter $n_M$ that records the number of
times it has grown.  When a mesh is permitted
to grow, we add 1 to the counter.  Then, if $L_i$ is the rest length
of the $i$th spring in the original undeformed mesh, we increase its rest
length to \newtext{$(1+n_Mk_g\Delta t_\mathrm{sim})L_i$}.  The constant $k_g$,
usually 0.01 in our system, controls the growth rate.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Stopping Criteria}
\label{repulsionpak_stopping_criteria}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


We choose one of two criteria to stop the simulation. First, the artist specifies 
the desired positive space ratio at which the simulation immediately terminates.
The ratio should not be set too high, and
we find that most packings have positive space ratios between $45\%$ and $65\%$ depending on the element shapes.
For example, concave elements with long extensions are more difficult to pack, 
so a lower positive space ratio is recommended to generate a satisfactory packing.
Second, we stop the simulation when the element meshes are no longer
able to maneuver enough to consume the remaining negative space. 
After each iteration, we compute an \textit{area fraction} $A$, defined to be the fraction of
the container area taken up by element meshes.  We then compute a measurement
of the recent change in area fraction in a sliding window that covers the $w$
most recent iterations of the system; we use $w=100$.  If $A_0,\ldots,A_w$
are the area fractions in the $w+1$ iterations up to the current one, then we
define

\begin{equation}
\mathrm{RMS} = \sqrt{ \frac{1}{w}\sum_{ i = 1 }^{w} { (A_i - A_{i-1}) }^2}
\end{equation}

We stop iterating when $\mathrm{RMS} < \epsilon$, where $\epsilon$ is $0.01$
in our system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Secondary Elements}
\label{repulsionpak_secondary_elements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The iteration process described above can leave behind isolated pockets of 
empty space, which will be visible in the final composition.  We imitate the
approach taken by human artists by filling these pockets will small, usually
simple secondary elements.  

We seed the container with secondary elements by finding points
that are far from any existing element mesh.  Specifically, we
compute a discrete approximation of the distance transform of the
negative space. We then create an initial candidate list of all
points for which the distance value is above a threshold $d_\mathrm{min}$, 
sorted by decreasing distance.  We consider each of these candidates in turn,
adding it to a final list of seed locations provided that no previously
chosen seed is within distance $d_\mathrm{sep}$ of the candidate.
In our implementation, if the distance transform is computed on a 
$1000\times 1000$ grid fit to the container's bounds, then we typically 
set $5 \leq d_\mathrm{min} \leq 10$ and $d_\mathrm{sep}=10$. 

Next, we assign random secondary elements to these chosen seed
points, scaled down as before to avoid overlaps.  We then run the
simulation and growth process again, but freeze the primary elements:
they exert repulsion forces on secondary elements and can induce
overlaps, but primary mesh vertices cannot move.  The secondary
elements gradually grow to consume some of the remaining negative
space until the packing satisfies the same stopping criteria
described above.

%Packings with secondary elements are shown throughout the paper; 
%see Figs.~\ref{pipeline}e, \ref{cat_packing}, and \ref{three_packings}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shape Matching}
\label{repulsionpak_shape_matching}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





The motions and deformations of elements, as described
in the previous sections, give them an opportunity to conform to each 
other and to the target container.  However, in some cases the random 
seeding may position some elements in such a way that the simulation 
process will still leave undesirable artifacts.  In particular, when
a round element is placed near a sharp convex corner of the container,
it cannot deform enough to extend into the corner, but cannot yield its
position to a pointy element that offers a better fit.  In the final
packing, the sharp corners of the containers will appear ``rounded off''.
Another problem occurs when a long narrow element is initially placed diagonally across a corner, 
in which case the simulation pushes the element's middle into the corner, causing extreme deformation.

To overcome these deficiencies, we optionally perform an initial fit-guided
placement pass before seeding the rest of the container at random. 
Here we take inspiration from existing rigid packing 
algorithms~\cite{Kwan2016}, which are driven primarily by shape 
compatibility.  We use a simplified shape descriptor; we can tolerate
a less perfect initial fit, with the expectation that deformation will
improve the quality later.

We begin by building shape descriptors for the elements.  
Each element is first scaled to have area
$0.6A_c/n_e$, where $A_c$ is the container area and $n_e$ is the 
number of elements.  This step resizes the element to a rough estimate
of its final size in the packing, an approximation that is adequate
for our fit-based placement.  We then sample the target container and
the boundaries of the elements, with adjacent samples separated by
distance $\delta$.  We set $\delta=0.002L_s$, where $L_s$ is the
side length of the container's bounding square.

We define a local descriptor based on integral of absolute curvature~\cite{Cui2009,Kwan2016}.
Let $P(t)$ be an arclength-parameterized 2D curve, and let $\kappa(t)$ represent the curvature of the curve at $P(t)$.  For a given interval $[s,t]$ within the curve's domain, we may define \newtext{the integral of absolute curvature:}
\newtext{\begin{equation}
\tau(s,t) = \int_{s}^{t} | \kappa(x) | dx.
\end{equation}}
In practice, we estimate curvature from the discrete sample points
using second-order forward finite differences~\cite{Banchoff2015} 
and compute $\tau$ by summing curvature estimates using the trapezoid rule.

Let an objective $\tau_\mathrm{obj}$ be a positive real number and $P(t_0)$ be a given point on a curve.  If $\tau_\mathrm{obj}$ is sufficiently small, then as we traverse the curve on either side of $P(t_0)$ we will eventually reach points $P(t_{-1})$ and $P(t_1)$ such that $\tau(t_{-1},t_0)=\tau(t_0,t_1)=\tau_\mathrm{obj}$.  We let $l_1=t_0-t_{-1}$ and $r_1=t_1-t_0$ be the arclengths that produce these integrals.  We can continue this process for any number of steps, walking in both directions along the curve away from previous sample points until we reach $\tau_\mathrm{obj}$, yielding new arclengths $l_k$ and $r_k$ (see Figure~\ref{fig_shape_matching}).  Finally, for a given number of steps $n$ \newtext{we define the shape descriptor at $P(t_0)$ as}
\newtext{\begin{equation}
(l_n, l_{n-1}, \ldots, l_2, l_1, r_1, r_2, \ldots, r_{n-1}, r_n)
\end{equation}}
Like PAD~\cite{Kwan2016}, our shape descriptor is rotation 
invariant.  Effectively it is one level of a PAD, which suffices because
we do not require scale invariance.
Descriptors can be compared using simple Euclidean distance, accelerated
by storing them in a k-D tree.
In our implementation we set $\tau_\mathrm{obj}=0.001L_s$; the dependence
on $L_s$ makes the measurement robust against changes in absolute container
size, and the factor of $0.001$ was determined through experimentation.
We further choose $n=5$, yielding a 10-dimensional descriptor. We compute
this descriptor for all the container and element samples defined above.

\begin{figure}[t]
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/descriptor_2.pdf}
\caption[A local shape descriptor for shape matching]
{\label{fig_shape_matching}
An illustration of a local shape descriptor with $n = 3$. 
These segments have varying arclengths but they all have the same value
of $\tau$, the integral of absolute curvature along their lengths.
}
\end{figure}



Based on these descriptors, we now use a simple greedy heuristic to identify salient container features where shape matching will be used.
Here we restrict our attention to convex protrusions with high curvature, which benefit the most from careful element placement (See Figure~\ref{rhino_packing}a).  Given a shape descriptor, we define its total length to be $\sum_{i=1}^nl_i+r_i$.  We iterate over all sample points on the container boundary in increasing order by the total lengths of their descriptors.  For each sample point $P(t_0)$, we add it to a list of salient features under two conditions. First, we require that the angle formed by $P(t_0)$ with two samples to either side of it be sufficiently acute; we use a threshold of 0.3 radians to ensure convex-to-convex matching.
Second, we ensure that salient features are not too close to each other by requiring that every new sample point be separated by a distance of at least $0.2L_s$ from all previously identified salient features.

\begin{figure}[t]
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/rhino_shape_matching_bitmap.pdf} 
\caption[A demonstration of shape matching to place elements]
{\label{rhino_packing}
{ 
A demonstration of shape matching of leaf shapes inside a rhinoceros. 
(a) We detect nine salient features, namely sharp convex corners, and 
assign an element to each.
(b) A spring holds each element in place.
(c) The final result.
}
}
\end{figure}

Even when an element's descriptor is a close match to a segment of 
target container, 
it may still not be safe to place that element at a given location.
For example, one part of an element may extend into a corner of the container,
while a different part, outside the purview of the local shape descriptor,
could protrude outside the container entirely.  We augment our 
descriptor-based fit calculation with an additional score adapted from
Gal et al.~\cite{Gal2007B} in order to ensure a more global element fit.
Let $d(\bm{x})$ be a signed distance function for the container, with
negative values inside the container and positive outside.  In practice we
superimpose a $1000\times 1000$ grid over the container's bounding square and
compute a discrete approximation of the distance transform.  For an element
sample point $\bm{x}$, we then compute a score
\begin{equation}
 q(\bm{x}) =\begin{cases}    
    e^{-\nicefrac{d(\bm{x})^2}{\mu^2\beta}}, & \mathrm{if} \;\; d(\bm{x}) < 0 \\
    1, & \mathrm{if} \;\;d(\bm{x}) = 0 \\
    - \alpha d(\bm{x}), & \mathrm{if}\;\; d(\bm{x}) > 0    
  \end{cases}
\end{equation}

With this scoring function, a sample point that lies on the container boundary
will have a score of 1, the maximum for $q(\bm{x})$.
Scores decay exponentially towards 0
for points farther inside the container.  Sample points outside the container
are penalized by assigning a negative score proportional to distance.

We then define a quality measurement for an entire element by summing over
all of its sample points:
\begin{equation}
Q = \sum_{i = 1}^{n_p} q(\bm{x}_i)
\end{equation}
The parameter $\alpha$ penalizes elements with parts that protrude outside
the container; $\beta$ favors elements with parts close to the target container; 
$\mu = 0.5 \sqrt{2}L_{s}$ is half of the diagonal of the container's
bounding square; and $n_p$ is the number of sample points on the element.
In our implementation we choose $\alpha = 1$ and $\beta = 0.001$.
For every salient container feature, we obtain the $10$ closest descriptors from the k-D tree, and choose one that has the highest $Q$.
Finally, we place the selected element in the container by 
aligning the endpoints of the element's and container's matching shape 
descriptors.

The shape matching process yields a set of elements that should be attached
to particular locations on the target container.  However, during simulation
they could wander away from these initial positions, under the influence of
the many other forces at play.  As shown in Figure~\ref{rhino_packing}b, we
encourage these elements to remain in place by attaching them to the salient
container points with additional springs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation and Results}
\label{repulsionpak_results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Our software was written in C++, and reads in text files describing
elements and containers; we prepared these files using
Adobe Illustrator.  We ran
our software on a computer with a 2.4 GHz Intel i7-4700HQ processor
and 16 GB of RAM.  As a post-process, we optionally read packings
back into Illustrator, fit smooth curves to polygonal paths, and
apply colors and other visual effects.  Table~\ref{packing_statistics}
shows statistics for the results \newtext{in this chapter}.  All results in this
\newtext{chapter} use \newtext{$\Delta t_\mathrm{sim} = 0.1$}.
Torsional forces are used only in Figure~\ref{giraffe_penguin_packing},
and shape matching is used only in Figure~\ref{rhino_packing}.
%We also use our improved method for resolving self intersection in
%Figs.~\ref{rhino_packing},~\ref{giraffe_penguin_packing},
%~\ref{paisley_packing},
%~\ref{pad_comparison}, and
%~\ref{balabolka_comparison}.


\newtext{The supplemental materials include movies that visualize the simulation
process\footnote{\url{https://cs.uwaterloo.ca/~radhitya/repulsionpak/supplemental_material.zip}}}.  
These movies make it clear that elements can jostle each other
around, inducing translation, rotation, and deformation throughout the 
simulation.

\begin{table}
\centering 
\caption[Data and statistics for the RepulsionPak results]
{
   Data and statistics for the RepulsionPak results.  The table shows the
   numbers of primary and secondary elements ($n_p$, $n_s$),
   the number of vertices ($v$), 
   the running times of the primary and the secondary simulations ($t_p$, $t_s$) in seconds,
   and the number of iterations ($i$).
   In these results, torsional forces are used only in 
   Figure~\ref{giraffe_penguin_packing} and shape matching is used only 
   in Figure~\ref{rhino_packing}.
   }
\label{packing_statistics}
\definecolor{lg}{rgb}{0.73,0.867,0.98}
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\cellcolor{lg}Packing                  & \cellcolor{lg}$n_p$ & \cellcolor{lg}$n_s$ & \cellcolor{lg}$v$   & \cellcolor{lg}$t_p$ & \cellcolor{lg}$t_s$ & \cellcolor{lg}$i$\\ \hline
Cats (Figure~\ref{cat_packing})                       & 41    & 69   & 3598  & 185  & 62  & 8531\\ \hline
Animals (Figure~\ref{fig_repulsionpak_pipeline})                       & 25    & 14   & 2412  & 133  & 65  & 16670\\ \hline
Rhino   (Figure~\ref{rhino_packing})        & 107   & 0    & 4833  & 237  & 0   & 15521\\ \hline
Birds  (Figure~\ref{three_packings}a)                 & 43    & 43   & 2309  & 102  & 54  & 11571\\ \hline
Bats (Figure~\ref{three_packings}b)                   & 47    & 22   & 3048  & 165  & 56  & 13120\\ \hline
Butterflies (Figure~\ref{three_packings}c)            & 123   & 135  & 11916 & 696  & 616 & 14379\\ \hline
Giraffes \& Penguins (Figure~\ref{giraffe_penguin_packing})        & 60    & 0   & 2250  & 163  & 0   & 9347\\ \hline
Paisley (Figure~\ref{paisley_packing})      & 162   & 0    & 4860  & 128  & 0   & 23040\\ \hline
Circles in Paisleys (Figure~\ref{paisley_packing})      & 144   & 0    & 2544  & 403  & 0   & 29584\\ \hline
\end{tabular}
\end{table}
%Collage (Figure~\ref{pad_comparison})       & 51    & 0    & 3481  & 729  & 0   & 29868\\ \hline
%Autumn  (Figure~\ref{balabolka_comparison}) & 77    & 0    & 2427  & 868  & 0   & 38387\\ \hline

The packing in Figure~\ref{cat_packing} 
uses six cat-shaped primary elements and one secondary cat head.
RepulsionPak naturally bends legs and tails to fill the container more evenly.

The animal packing in Figure~\ref{fig_repulsionpak_pipeline} 
has several elements with limbs (the bear, fox, chick, and penguin),  
extensions (the dog and bunny ears), and long shapes (the snake).
Figure~\ref{fig_defviz} highlights the deformations for some of these elements;
they are noticeably more deformed 
than nearly convex elements like the cat and mouse.


The butterfly packing in Figure~\ref{three_packings} is an attempt to reproduce 
the visual style of a dense packing (or tessellation), similar to Jigsaw Image Mosaics~\cite{Kim2002}
or the ``Butterflies in Butterfly'' example from the
Pyramid of Arclength Descriptor paper~\cite{Kwan2016}. 
The target container is made from two regions,
one with internal holes.  The resulting packing is tight but overlap-free.

\newtext{The bird packing} in Figure~\ref{three_packings}
exhibits significant deformation in the wings and the tails of the birds.
In particular, the thin tails of the swallows have some unaesthetic
sharp bends.  We would like to investigate ways to ensure these bends are
smoother.



\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/allresults.pdf} 
\caption[Three packings created using RepulsionPak: Birds, Bats, and Butterflies]
{\label{three_packings} Three packings created using RepulsionPak: Birds, Bats, and Butterflies. The results are visually appealing overall, though some birds' tails suffer from excessive deformation in
the packing on the left.}
\end{figure}

The packing in Figure~\ref{giraffe_penguin_packing} demonstrates torsional forces
that gradually turn the elements upside down. 
The rhinoceros packing in Figure~\ref{rhino_packing} demonstrates initial placement via shape matching.
The entire shape matching process took 922 milliseconds with a 4-element library.



\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/giraffe_penguin.pdf}
\caption[A packing that demonstrates torsional forces]
{\label{giraffe_penguin_packing}
A packing that demonstrates torsional forces.
The packing uses copies of a single element shape, but every copy is given a rest orientation between $0^\circ$
and $180^\circ$, based on its horizontal position in the container.  In the final packing the elements transition
from upright to upside-down, recreating an illusion in which giraffe heads become penguins.}
\end{figure}

We have also experimented with creating tileable packings, as shown
in Figure~\ref{paisley_packing}.  We seed a central square with elements,
but also place clones of those elements in all the squares of the
8-neighborhood around the center.  These clones track the transformations
and deformations of their originals, but also exert forces on them during
simulation, leading to an even, seamless packing in a toroidal domain.

%\begin{minipage}{\textwidth}
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/paisley_new.pdf} 
\vspace{-10pt}
\caption[A paisley-inspired toroidal packing]
{\label{paisley_packing}
A paisley-inspired toroidal packing that can tile the plane. 
           (a) An initial paisley packing.
           (b) In a separate simulation, we fill each paisley with circles to demonstrate a packing inside a packing.
           (c) The final result.
}
\end{figure}

We have found that RepulsionPak is robust to parameter variation, and 
produces predictable, high quality results without the need for fine-grained
adjustments.  However, as shown in Figure~\ref{bad_results}, extreme parameter 
settings can still produce degenerate results.
In Figure~\ref{bad_results}a, the repulsion force is made much stronger than 
the edge force, leading to excessive element deformation and
self-intersections in the pursuit of even negative space.  In 
Figure~\ref{bad_results}b, edge and torsional forces dominate repulsion,
producing a packing with stiff, upright elements that do not fill their
container effectively.


\makeatletter % bruh
\setlength{\@fptop}{0pt} % bruh
\makeatother % bruh
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/repulsionpak/bad_results.pdf} 
\vspace{-12pt}
\caption[Two examples of how extreme parameter values can lead to \newline 
	low-quality results]
	{\label{bad_results}
Two \newtext{examples} of how extreme parameter values can lead to
	low-quality results.  In~(a), we allow repulsion to overwhelm element
	shape by setting $k_\mathrm{rpl}$ to 200 and $k_\mathrm{edg}$ to 20; the resulting packing 
	has even negative space, but elements suffer from high deformation
	and \newtext{self-intersections}.  In~(b), we minimize repulsion and prioritize
	orientation by setting $k_\mathrm{edg}$, $k_\mathrm{tor}$, and $k_\mathrm{rpl}$ to 200, 100, and 50,
	respectively.  The elements deviate minimally from their original shapes 
	and orientations, but cannot fill the container effectively.
}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{repulsionpak_conclusions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\mynote{need to move a few sentences to evaluation}
%\mynote{remove validation}

We presented RepulsionPak, a method to create packings with deformable elements.
Each element is represented as a
mass-spring system, allowing it to deform to achieve a better fit with
its neighbors and the container.
The combination of repulsion forces and controlled deformation
allows RepulsionPak to create shape compatibilities that
eliminate the need for a large element library
and fill the target container effectively.

%\newtext{
%Our compositions have negative space between elements that
%is approximately uniform in width, and we validate our approach using overlap functions,
%spherical contact probability functions, and distance histograms.
%}

