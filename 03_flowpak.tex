%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter
{FLOWPAK: Flow-Based Ornamental Element Packing}
\label{chapter_flowpak}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/lion_unicorn.pdf} 
\caption[Packings of lion and unicorn]
{\label{fig_lion_unicorn} 
Ornamental packings of a lion and a unicorn.
The diagram next to each animal shows a set of four ornamental
elements used in the packing (top) and the annotated
container regions (bottom).  Each ornamental element has a
red spine that is used to deform it along a streamline.  In
the containers, black curves represent boundaries, red
curves with arrows represent directional guides, and green
curves are fixed elements copied into the final design.
The colors in the final rendering were added manually. }
\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{flowpak_introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF




\newtext
{
FLOWPAK~\cite{Saputra2017} is a technique for filling a container 
region with elements that are deformed 
to communicate a sense of directionality or flow.
%Flow adds visual interest to a composition,
%engaging the viewer by providing a sense of progression and
%movement through elements.
Elements have designs of simple geometric forms, often stylized flora, spirals, or other abstract shapes. 
Figure~\ref{dog_flow} shows four examples of these sorts of compositions, which we refer to as ornamental packings.
%A hand-drawn dog example in Figure~\ref{dog_flow}a shows many elements that appear to flow
%outward from the flower in the centre of the torso, and then
%up the neck and down into the legs.
%Although there has been a moderate amount of past research on
%the generation of packings or mosaics,
%this past work is not appropriate for creating flow-like
%designs similar to the dog example.
}



\newtext{
In studying designs like those in Figure~\ref{dog_flow}, we 
have identified five high-level principles that are important
to ornamental packing construction:
}




\begin{items}%[leftmargin=*]
\item \textbf{Balance.} A composition does not exhibit too
  much variation in local amounts of positive and negative space.
  Typically, this goal is accomplished by limiting variation in 
  the diameters of elements (controlling the variation in
  positive space), and in ensuring that elements are spaced 
  evenly (controlling negative space).

\item \textbf{Flow.} In local parts of a composition, the elements
  are oriented to communicate a sense of directionality or flow.
  All of the examples in Figure~\ref{dog_flow} exhibit 
  some amount of flow.  In the dog, many elements appear to flow
  outward from the flower in the center of the torso, and then
  up the neck and down into the legs.  The scales and other elements
  on the fish flow along the length of its body.  In the lion and skull,
  elements flow horizontally outward from a central axis of symmetry,
  suggesting fur in the case of the lion.  
  Flow  adds visual interest to a composition, engaging the viewer 
  by providing a sense of progression and movement through elements.

\item \textbf{Uniformity Amidst Variety.} Repeated elements must balance
  between two opposing forces.  \textit{Uniformity} 
  aims for an overall unity of design; \textit{variety}
  seeks to break up the monotony of
  pure repetition.  Elements should be permitted to vary in shape,
  but in a controlled way.  We refer to this principle
  as \textit{uniformity amidst variety}, a term borrowed from 
  philosopher Francis Hutcheson~\cite{Hutcheson1729}.
  Gombrich also writes eloquently on the role of variation in 
  design~\cite{Gombrich}.
  In our examples, the dog's spirals and the
  fish's scales both obey this principle.  The lion and skull do as well,
  except that half of the elements are reflected copies of the other
  half, across a vertical line through the center of the composition.
  This repetition emphasizes the bilateral symmetry in the design.

\item \textbf{Fixed Elements.} Compositions use a small number of fixed
  elements to solve specific design problems or provide focal points.
  In any figurative drawing, eyes serve as a powerful focal point;
  every example in Figure~\ref{dog_flow} has eyes drawn
  in as unique elements
  (the dog's eye is expressed via a carefully placed spiral).  Other
  situations that call for specialized shapes include the dog's paws,
  the fish's teeth and fins, 
  the lion's eyes and nose, %%% REZA BACKUP
  and the skull's teeth.
  Sharp variation in the balance of positive and negative space
  can also be used to emphasize a focal point,
  as in the fish's head and the lion's face that contain considerable amount of empty space.

\item \textbf{Boundaries.} In many ornamental packings, elements are
  carefully arranged to conform to and emphasize container boundaries.
  The fish demonstrates this principle most clearly: we can easily
  fill in the gaps between elements to form a mental image of a continuous
  outline.  The dog's elements are also well aligned to indicate the
  container shape.  However, this rule is not universal.  
  The lion artfully subverts it with elements that flow outward to an
  indistinct boundary, helping to convey the appearance of fur.
\end{items}

\begin{figure}[t!] %%% ELEMENT IMAGE
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/dog_ornament_flow.pdf}
\caption[Examples of flow visual style]{
  \label{dog_flow}  
\newtext
{
Examples of ornamental packings: 
(a) Dog (by ComicVector703 on Shutterstock), 
including a visualization showing the flow directions of elements; 
(b) Lion (from StockUnlimited);  
(c) Skull (by alitdesign on Shutterstock).
(d) Fish in the style of Haida art (by Russ Jones, used with permission); 
}
}
\end{figure}

In FLOWPAK, elements can be oriented in the local direction 
of flow, but can also be deformed to capture changes in flow direction.
We express the user's desired flow by placing evenly spaced streamlines
inside the container region.  Each streamline is then replaced by an
element chosen from a pre-drawn set.  The element is bent along the streamline
to communicate flow, and also deformed to balance the usage of negative space
with elements placed on adjacent streamlines.  The final designs, such
as the lion and unicorn shown in Figure~\ref{fig_lion_unicorn}, aim to obey the
design principles articulated above.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
\label{flowpak_previous_work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\newtext{
\textbf{Packings:}
Chapter~\ref{chapter_related_work} discusses
methods on the generation of packings, or mosaics. 
However, past work is not appropriate
for creating designs like those of Figure~\ref{dog_flow}.
Most techniques pack elements via rigid transformations, leading to
high uniformity but insufficient variety.  We design FLOWPAK 
to be a deformation-driven approach so that it can generate plausible families of related decorative elements
from a single input shape.  %They also focus on packing large numbers
%of small elements.  We are interested in the compositional properties
%of large, visually distinct elements.
}

\newtext
{
\textbf{Decorative Ornaments:} A distinct category of past research seeks to develop explicit procedural
models for authoring decorative patterns.  Wong et al.~\cite{Wong1998}
articulated a set of design principles for decorative art:
repetition, balance, and conformation to geometric constraints.  They
went on to describe a grammar-like system for laying out floral ornament.
Bene\v{s} et al.~\cite{Benes2011} developed an interactive 
interface to guide procedural models in generating decorative elements.
The recent PATEX system by Guerrero 
et al.~\cite{Guerrero2016} preserved high-level geometric relationships
like symmetry and repetition while ornamental designs are edited.
Gieseke et al.~\cite{Gieseke2017} developed a user interface where an artist 
can generate a decorative pattern by specifying design principles such as flow, balance, and symmetry.
Li et al.~\cite{Li2019} developed a method that can produce a 2D quilting pattern
by generating connected stitch paths, 
each is then decorated by ornamental elements.
}

\newtext
{
\textbf{Decorative Strokes:}
FLOWPAK is related to decorative stroke methods since we aim to deform long thin elements. 
The goal of these methods is to create stylized decorative strokes, and not to fill a container area. 
Hsu et al. developed Skeletal Strokes~\cite{Hsu1993}, a method to warp decorative patterns along a stroke.
Asente~\cite{Asente2010} improved upon Skeletal Strokes by correcting severe deformation on high-curvature strokes.
Lu et al. developed DecoBrush~\cite{Lu2014} that can join multiple decorative patterns seamlessly.
}

\newtext
{
\textbf{Vector Field-Guided Compositions:} 
FLOWPAK requires elements to be deformed and oriented according to a vector field.
Maharik et al. explored Digital Micrography~\cite{Maharik2011}, in which
lines of small-scale text are deformed to fit along dense streamlines in a container.
These streamlines are traced from a user defined vector field.
We take inspiration from their method, but seek to place fewer,
larger elements taken from a small library of elements and to use shorter, sparser, and less regular streamlines. 
Xu and Mould~\cite{Xu2009} developed a tracing method of particles in a magnetic field to
generate decorative curves.
In separate work, Xu and Mould~\cite{Xu2015} proposed a graph-based tree synthesize method that is guided by vector fields.
Li et al.~\cite{Li2010} developed a method to decorate a surface using a shape grammar that is guided by a tensor field.
}

\newtext
{
\textbf{Decorative Ornaments on Surfaces:} 
Related methods in fabrication has sought to cover surfaces with
arrangements of decorative elements that satisfy manufacturing
constraints such as connectivity~\cite{Chen2016, Zehnder2016, Bian2018, Martinez2019}.
Elements must be tightly connected to produce a connected result
that will hold together when 3D printed.
In the case of FLOWPAK, we seek to distribute disconnected elements inside a container.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Formulation}
\label{flowpak_problem_formulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We formally define the problem to be solved as follows.  The user provides several pieces of input
to our system:
\begin{enumerate}
      \item A set of target containers.
            Each container 
			is a closed curve to be filled with ornamental elements.
      \item A set of direction guides
      		that guide the placement algorithm, defining the flow of the results. 
      		Every target container must have at least one guide, and some or
      		all of the guides typically follow the container boundaries.
      \item An optional set of fixed elements that we transfer directly to the result.
      \item A set of ornamental elements, each with a spine that will control
            its deformation.
\end{enumerate}

%\newtext{The first three inputs are combined into a single diagram, where they are
%distinguished by their colors; see
%the drawing in Figure~\ref{fig_flowpak_pipeline}a.}
The first three inputs are combined into a single diagram, where they are
distinguished by their colors; see
the left and right drawings in Figure~\ref{fig_lion_unicorn}.
The goal of our algorithm is to fill each target container with elements,
trying to satisfy several guiding principles:

\begin{enumerate}
	\item Follow the flow defined by the direction guides.
	\item Have as little empty space as possible.
	\item Make the spacing between elements be as even as possible.
	\item Conform to container boundaries.
	\item Vary element width and length to avoid an excessively uniform arrangement.
\end{enumerate}
The next section describes how we achieve these results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Approach}
\label{flowpak_approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



Figure~\ref{fig_flowpak_pipeline} gives an overall view of our system. The numbers in the following
steps correspond to parts of the figure.


\begin{enumerate}
  \item Read the input target containers and
  copy any fixed elements to the output art (Section~\ref{flowpak_target_containers}).
  \item Analyze the ornamental elements, creating a shape descriptor for each
   (Section~\ref{flowpak_ornamental_element_and_lr_functions}).
  \item Use the direction guides to fill each target container with a vector field then trace streamlines 
  (Section~\ref{flowpak_creating_vector_fields_and_tracing_streamlines}).
  \item Divide the target containers into blobs around the streamlines (Section~\ref{flowpak_subregion_blobs}).
  \item Use the element shape descriptors to determine the best element for each blob. 
        Place the element in the blob, treating it as a skeletal stroke and mapping its
        spine to the streamline (Section~\ref{flowpak_shape_matching_and_deformation}).
  \item Iteratively refine the placement to eliminate empty areas and make the spacing more even (Section~\ref{flowpak_iterative_refinement}).
\end{enumerate}

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}[th]
\vspace{-10pt}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/pipeline.pdf} 
\caption[FLOWPAK pipeline]
{\label{fig_flowpak_pipeline} 
A visualization of the steps in our ornamental packing algorithm.
The input containers are shown as three black outlines in (a): the body
and two fins.  They are annotated with directional guides in red and fixed elements (in this 
case, the eye) in green.  The steps in the algorithm follow the
description at the beginning of Section~\ref{flowpak_approach}.
}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Target Containers}
\label{flowpak_target_containers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The input diagram contains a set of target containers. Each is a single
closed curve defining an area
to be filled.  Most non-trivial examples include more than one target
container.  For the most part, our algorithm fills each container separately,
and so the following explanation is given in terms of a single container.
Containers will later be merged in the iterative refinement step.

The artist has the option of including a set of fixed elements that
we copy directly into the final result. The following sections
include descriptions of how the fixed elements affect the filling
algorithm.

We define $input\_size$ to be the maximum of the combined width or height
of all the target containers and fixed elements as laid out by the artist.
This value will
be used to set various parameters in the synthesis process.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ornamental Elements and LR functions}
\label{flowpak_ornamental_element_and_lr_functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An ornamental element is defined as one or more closed curves.  Our placement method will
eventually deform copies of the element (Section~\ref{flowpak_shape_matching_and_deformation}) 
using a simple skeletal stroke algorithm~\cite{Hsu1993},
so each element must be annotated with a straight spine to guide the deformation.  The spine
does not need to go through the center of the element---it can be anywhere.

We define two classes of elements: a \textit{full element} extends across
both sides of its
spine, and a \textit{half element} lies entirely on one side of its spine.
Figure~\ref{ornamental_shapes_fig} shows examples of full and half elements.  If the input
to our algorithm includes direction guides that coincide with target container boundaries,
the placement method will align half elements along these boundaries.  
If half elements 
have edges that closely follow their spines, they will visually reinforce
container boundaries, as shown in our examples.

We define a simple shape descriptor called an \textit{LR function}
that will be used in
Section~\ref{flowpak_shape_matching_and_deformation} to choose which element to place in a particular location. 
Inspired by the work of Gal et al.~\cite{Gal2007A}, we sample the element's
spine at $n$ locations and at each location determine how far the ornament extends to the
left and right of the spine. The LR function is the set $\{L, R\}$ where $L=\{\ell_1,\ldots,\ell_{n\text{\_}f}\}$
is the left function and $R=\{r_1,\ldots,r_{n\text{\_}f}\}$ is the right function. The number of samples is denoted by $n\text{\_}f$.

The LR function is made scale-invariant by normalizing its
domain and range to $[0,1]$.  Note that swapping the $L$ and $R$ functions
corresponds to reflecting the element across its spine, and reversing each
of $L$ and $R$ corresponds to reflecting the element along its spine.  We
will consider all four combinations of these two reflections when placing 
an element in a blob (Section~\ref{flowpak_subregion_blobs}),
in order to achieve the best possible fit.

Intuitively, LR functions give an approximate area an ornamental element can claim.
Figure~\ref{ornamental_shapes_fig} 
shows elements with their left values
in blue and their right values in red. We have found that \newtext{$n\text{\_}f = 100$} gives sufficient
granularity for our algorithm.

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/ornaments.pdf}
\caption[Ornamental elements and their LR functions]
{\label{ornamental_shapes_fig}
Ornamental elements and their LR functions. Full elements have non-empty
left and right sides, while half elements have only one non-empty side. 
We normalize the LR functions to a unit square.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating Vector Fields and Tracing Streamlines}
\label{flowpak_creating_vector_fields_and_tracing_streamlines}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To implement the flow principle described in the introduction, we fill each target
container with a vector field, constrained by the direction guides in that container.

We sample the directional guides $D = \{ d_{1}, d_{2}, ... , d_{n\text{\_}d}\}$  
and use the tangent at every sampled point as a directional constraint.
We then construct a vector field using the $N$-RoSy algorithm
of Palacios and Zhang\cite{Palacios2007}.  Note that, as shown in 
Step~3 of Figure~\ref{fig_flowpak_pipeline},
fixed elements do not affect the vector field.  
The artist can include directional guides to guide the vector field around fixed elements if desired.

\newtext
{
The next step is to trace streamlines in the vector field, guided by three input parameters:
\begin{packeddescriptions}
\item[$s\_gap$] is the desired space between streamlines;
\item[$s\_max$] is the maximum desired streamline length; and
\item[$s\_min$] is the minimum desired streamline length.   
\end{packeddescriptions}
Because we will ultimately place elements along streamlines without overlap, \newtext{$s\_gap$} determines
the approximate width of the placed elements, and \newtext{$s\_max$} the maximum length.  We also derive
a value \newtext{$s\_stop$} that prevents streamlines from coming too close to each other; in our implementation we
compute \newtext{$s\_stop = 0.8\,s\_gap$}.
}

We adapt the streamline tracing algorithm of Jobard and Lefer~\cite{Jobard1997}.
First we generate a set of potential seed points $P = \{ \bm{p_{1}}, \bm{p_{2}}, ... , \bm{p_{n\text{\_}p}}\}$  by
densely resampling the target container boundary $T$ and the directional guides in $D$.
We use a sampling distance of $0.005\,input\_size$.
The first streamline $s$ is generated by randomly removing a seed point from $P$ and following
the vector field until one of the following conditions holds:

\begin{enumerate}
\item the length of $s$ would exceed \newtext{$s\_max$}.
\item $s$ would come within \newtext{$s\_stop$} of another streamline.
\item $s$ would cross $T$, leaving the container.
\item $s$ would cross the boundary of a fixed element.
\end{enumerate}


If the length of $s$ is less than \newtext{$s\_min$}, we discard it. Otherwise we sample 
$s$, again using $0.005\,input\_size$, and at each point generate two more
potential seeds that are \newtext{$s\_gap$} away from $s$ on either side. If a seed is
inside the container, we add it to $P$.  The process is repeated until $P$ is empty.
Note that the \newtext{$s\_stop$} distance test combined with the \newtext{$s\_min$} length
test imply that many attempts to form streamlines will stop immediately,
especially as the container fills with streamlines.

Figure~\ref{streamline_tracing} shows the creation process, and 
Algorithm~\ref{tracing_streamlines} shows the pseudocode.
The sort function \textsc{Sort}$(P)$ orders the points in $P$ according to their distance from the
boundary $T$ and the directional guides in $D$, with closer points first and equally distant
points ordered randomly. Because the initial points are all on $T$ or on a path in $D$, their
sort value is zero, and they will be processed before any derived points. 

\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/streamline_tracing.pdf}
\caption[The streamline tracing process]
{\label{streamline_tracing}
The streamline tracing process. The first streamline $s_1$ always begins
on a directional guide or the container boundary.  Subsequent streamlines begin
on the container boundary, a directional guide, or at a point that is 
\newtext{$s\_gap$} away from a previous streamline.}
\end{figure}

\begin{algorithm}
\caption{Tracing Streamlines} 
\label{tracing_streamlines}
\begin{algorithmic} 
\STATE Create a seed list $P = \{ \bm{p_{1}}, \bm{p_{2}}, ... , \bm{p_{n\text{\_}p}}\}$ 
       by uniformly resampling
\STATE \hskip\algorithmicindent $T$ and the guides in $D$.
\STATE Create an empty set $S$ of streamlines.
\STATE Randomly order the elements of $P$.
\WHILE {$P$ is not empty}
  \STATE Generate a new streamline $s$ from $\bm{p_{1}}$.
  \STATE Remove $\bm{p_{1}}$ from $P$.
  \IF {$s$ is longer than \newtext{$s\_min$}}
    \STATE Add $s$ to $S$.
    \STATE Create seed points that are \newtext{$s\_gap$} away from $s$ and
	\STATE \hskip\algorithmicindent add them to $P$.
    \STATE \textsc{Sort}$(P)$.
  \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}



%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sub-Region Blobs}
\label{flowpak_subregion_blobs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To assist in choosing which element to place along each streamline, we first
subtract the areas of any fixed elements from the target container. We then
construct an approximate generalized Voronoi diagram of the interior
using the method of Osher and Sethian~\cite{Osher1988}.
The streamlines are then extended at each end, following the vector field, until
they encounter the boundaries of their Voronoi regions.
We call the area around each streamline a \textit{sub-region blob}.
Step~4 of Figure~\ref{fig_flowpak_pipeline} 
\newtext{shows the blobs of the fish.}

We then compute an LR function for each blob as described in Section~\ref{flowpak_ornamental_element_and_lr_functions},
using the streamline as the spine. Because the streamline is not usually straight, we 
compute the left and right distances along the normals to the streamline. The LR function approximates
the blob's shape if the streamline were to be straightened.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shape Matching and Deformation}
\label{flowpak_shape_matching_and_deformation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The next step is to place an ornamental element in each blob.  We choose which element
to place in the blob by finding the element that minimizes a sum of least squares distance, defined as
%\vspace{-4pt}
\begin{equation}
\sum_{i=1}^{N} (\alpha_{li} - \beta_{li})^2 + \sum_{i=1}^{N} (\alpha_{ri} - \beta_{ri})^2
\end{equation}
where
%\vspace*{-4pt}
\begin{conditions}
\alpha_{l}\enspace & the element left function;\\
\alpha_{r} &  the element right function; \\   
\beta_{l}  &  the blob left function; and \\
\beta_{r}  &  the blob right function.
\end{conditions}
%\vspace{-4pt}

Every element can be placed in one of four orientations, by optionally 
incorporating reflections across and along its spine.  These reflections
correspond, respectively, to swapping the $L$ and $R$ functions and reversing
them.  When comparing the LR functions for an element and a blob, we compute
the least squares distances for all four orientations and choose the 
orientation with the smallest distance.  Note that this matching method
automatically places half elements along streamlines that follow container
boundaries, visually reinforcing the overall shape.

We investigated alternatives for shape matching, using an approach
discussed by Gal et al. \cite{Gal2007B} that tries to fill a sub-region
blob as much as possible, with heavy penalties if a part of an
element protrudes outside the boundary of the blob. However, we found
this computation to be more expensive without providing significant
advantages over our LR functions.

Once we have chosen an element, we place it along the streamline using a
simple skeletal stroke algorithm~\cite{Hsu1993}. We uniformly scale the element's width
to make it as wide as possible while still staying inside the blob
(Figure~\ref{shape_deformation}).

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/shape_deformation.pdf}
\caption[Shape deformation]
{\label{shape_deformation}
The deformation process bends the element along the streamline and
scales it to fit inside the blob.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Iterative Refinement}
\label{flowpak_iterative_refinement}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now refine the overall composition in an iterative process.  We perform
this part of the algorithm globally, by merging all containers and allowing the
elements within them to interact.

The refinement process aims to reduce the amount of negative space and make it
more even by growing and shifting the placed ornamental elements. It would be 
possible to use a greedy approach, improving the placement of each element as much
as possible before moving on to the next, However, we have found that gradually
improving the placement of all elements leads to a more even result.

Each refinement
iteration has two phases.
First, we shift the streamlines to more accurately follow the space that is available,
as shown in Figure~\ref{shift_streamline}. After shifting, we recalculate the LR function
for the blob to reflect the new position, and repeat a variant of the
element placement process
that allows the elements to rotate slightly in their space.
Second, we expand each blob to allow it to use adjacent space that is not 
filled with another element, as shown in Figure~\ref{stretch_ornament}.

Each refinement iteration considers the blobs in increasing order of 
placed element area, allowing smaller elements to grow more.   While each step
usually results in a larger placed element, some
configurations can result in a smaller one. We only accept the new element if its
area is no smaller than $\alpha$ times its old area, where $\alpha$ is a growth tolerance
that we set to $0.9$. Elements therefore have some freedom to grow or
shrink, in the search for more globally even spacing.

Algorithm~\ref{iterative_refinement_algorithm}
gives the overall method, and the following sections give details. We have found that
15 iterations suffice for most designs.
Note that in Algorithm~\ref{iterative_refinement_algorithm}, the variable
$E$ is the list of placed, distorted ornamental elements, and
not the set of prototype elements discussed earlier.

\begin{algorithm}
\caption{Iterative Refinement} 
\label{iterative_refinement_algorithm}
\begin{algorithmic} 
\REQUIRE $E = \{ e_{1}, e_{2},... , e_{n\text{\_}e} \}$ as the ornamental element list. 
\REQUIRE $S = \{ s_{1}, s_{2},... , s_{n\text{\_}s} \}$ as the streamline list.
\REQUIRE $B = \{ b_{1}, b_{2},... , b_{n\text{\_}b} \}$ as the blob list.
\REQUIRE $\alpha$ as the growth tolerance
\REQUIRE $t$ as the number of iterations
\FOR {$t$ times}

  \STATE Sort $E$, $S$, and $B$ by \textsc{Area}$(e_{i})$ (smallest first)
  \FOR {Element $e_{i}$ in $E$}
  	\STATE $s_{i}$ is the corresponding streamline of $e_{i}$
    \STATE Calculate $s'_{i}$ by \textbf{shifting} $s_{i}$.
    \STATE Recompute the LR function of $b_{i}$ to give $b'_{i}$
    \STATE Calculate $e'_{i}$ by \textbf{placing} $e_{i}$ inside $b'_{i}$
    \IF{$\textsc{Area}(e'_{i}) \times \alpha > \textsc{Area}(e_{i})$}
        \STATE $s_{i} \leftarrow s'_{i}$
        \STATE $b_{i} \leftarrow b'_{i}$
    	\STATE $e_{i} \leftarrow e'_{i}$ 
    \ENDIF
  \ENDFOR
  \STATE Sort $E$, $S$, and $B$ by \textsc{Area}$(e_{i})$ (smallest first)

  \FOR {Element $e_{i}$ in $E$}
  	\STATE $b_{i}$ is the corresponding blob of $e_{i}$
    \STATE Calculate $b'_{i}$ by \textbf{growing} $b_{i}$.
    \STATE Calculate $s'_{i}$ based on $b'_{i}$ 
    \STATE Calculate $e'_{i}$ by \textbf{placing} $e_{i}$ inside $b'_{i}$\
    \STATE $b_{i} \leftarrow b'_{i}$
    \IF{$\textsc{Area}(e'_{i}) \times \alpha > \textsc{Area}(e_{i})$}
        \STATE $s_{i} \leftarrow s'_{i}$
    	\STATE $e_{i} \leftarrow e'_{i}$ 
    \ENDIF
  \ENDFOR

\ENDFOR
\end{algorithmic}
\end{algorithm}





\textbf{Shifting Streamlines.}
There are two issues that keep the initial placement of elements from being
evenly
distributed. Our streamline placement method keeps streamlines apart,
but they may not be spaced completely evenly. More significantly, the
ornamental elements often have unbalanced left and right sides and concavities,
leading to extra space on one side or the other.  Our refinement process
shifts streamlines to address these problems.

The shifting process allows the endpoints of the streamline to move to the
left or the right relative to the streamline, depending on which side has more empty space.
This allows the streamline's element to become wider and fill more of the space
(Figure~\ref{shift_streamline}). It also gives the streamline room to
extend if its endpoints were too close to boundaries of other placed
elements.

\begin{figure}
 \includegraphics[width=1.0\textwidth]{figures/flowpak/shift_streamline.pdf}
 \caption[Shifting a streamline]
 {\label{shift_streamline}
 Streamline shifting.
  We move the streamline's start and end points along 
  perpendiculars, stopping before intersecting neighboring elements.}
\end{figure}


Given the endpoints $\bm{p_\mathrm{start}}$ and $\bm{p_\mathrm{end}}$, we 
calculate new endpoints $\bm{p'_\mathrm{start}}$ and $\bm{p'_\mathrm{end}}$.
We generate perpendicular
vectors to the left side and to the right side at each endpoint and construct
a line segment joining the points where the vectors intersect other placed elements.
We then move the endpoint of the streamline towards the midpoint of this
segment. To enforce the principle of gradual refinement, we do not allow the
endpoint to move more than $g_\mathrm{limit}$ units, where 
$g_\mathrm{limit}=0.005\,input\_size$ (Recall that $input\_size$ is the maximum dimension
of the design as described in Section~\ref{flowpak_target_containers}).

We replace the streamline with a path joining
$\bm{p'_\mathrm{start}}$ and $\bm{p'_\mathrm{end}}$. Our goal
is to create a path that is smooth and does not deviate too much from the vector
field.  We calculate the shifted streamline by performing Dijkstra's
algorithm on a non-rectangular graph that respects the vector field
(Figure~\ref{dijkstra}), using a method similar to one by Xu and Mould~\cite{Xu2015} for
pathfinding in a vector field.

\begin{figure}
\includegraphics[width=1.0\textwidth]{figures/flowpak/dijkstra.pdf}
 \caption[Tracing a shortest path]
 {\label{dijkstra}
 Tracing a shortest path using Dijkstra's algorithm.  We generate the 
 orange nodes by resampling and offsetting the blue red streamline.
          The search directions at a node are shown with green arrows.}
\end{figure}

To construct the graph, we begin by densely sampling the original
streamline with a distance of $0.25\,g_\mathrm{limit}$. We then duplicate
the points, offset to the left and right, again using $0.25\,g_\mathrm{limit}$.
The duplication is repeated until the graph extends to the left and right of the
streamline by a distance equal to the maximum left and right widths of the blob (i.e.,
the maximum values in an unnormalized version of the blob's LR function).

For a node, we check its $N = 150$ nearest neighbors, considering only neighbors where the angle between the line into the current node and the line to the neighbor form an angle greater than $90^\circ$, thereby preventing
the streamline from backtracking.
The cost of an edge from $\bm{n_a}$ to  $\bm{n_b}$ is 

\begin{equation}
w = w_f (1 - f^p) + w_d \: D(s_i, \bm{n_a})
\end{equation}
where
\begin{conditions}
f                  & $(\bm{n_b} - \bm{n_a}) \cdot \bm{v}$; \\
\bm{v} 		   & a sampled vector of the vector field; \\
s_i                & the original streamline; and \\   
D()\enspace        & a distance function between a polyline and a point.
\end{conditions}

In practice, we set $w_d = 0.1$, $w_f=1$, and $p = 3$.

After finding a set of points, we fit cubic B\'ezier curves using a method
devised by Schneider \cite{Schneider1990} and extend the path at both ends 
by following
the vector field until it intersects the edges of its blob. 




\textbf{Growing Blobs.} The growth process tries to enlarge each sub-region blob to
claim empty space.
Given a blob $b_{i}$, we calculate a larger blog $b'_{i}$ 
by offsetting its boundaries until they intersect other placed elements (Figure~\ref{stretch_ornament}).
To enforce gradual growth, the offset cannot be larger than $g_\mathrm{limit}$, where
$g_\mathrm{limit}=0.005\,input\_size$.

The value $g_\mathrm{limit}$ used in growing blobs and shifting streamlines limits the speed of
the refinement.  Making it larger would require fewer iterations to fill the available space,
but at a cost of elements growing less evenly. 

% ROTATING OR FLIPPING
\textbf{Element Placement.}
In the refinement process, we allow a more flexible element placement so that
the elements can fill more of their blobs.  We allow the element
to rotate by a small amount, up to ten degrees, before placing it, as shown in
Figure~\ref{rotate_ornament}. 
We generate rotated versions of $e_{i}$ 
with varying angles $r_\mathrm{angle} = {1^{\circ}, 2^{\circ}, 3^{\circ}, ..., 10^{\circ}}$
and precompute LR functions for each. The shape matching algorithm
(Section~\ref{flowpak_shape_matching_and_deformation}) automatically choses the best rotation. It
can also choose to reflect the element across its spine, along its spine, or both (Figure~\ref{flip_shape})

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/stretch.pdf}
\caption[Stretching an element]
{\label{stretch_ornament}
(a) An element with its sub-region blob shown in dashed blue line. Note that any blob is constrained by the neighboring elements. 
(b) The dashed red line is the grown blob, which accommodates an enlarged element.}

\bigskip
% ROTATING OR FLIPPING
\includegraphics[width=1.0\textwidth]{figures/flowpak/rotate_ornament.pdf}
\caption[Rotating an element]
{\label{rotate_ornament}
Top row: rotated versions of the original element. 
         The best rotation angle is chosen via least squares matching.
         Bottom row: original, rotated, and enlarged versions of an element.}
\bigskip

\includegraphics[width=1.0\textwidth]{figures/flowpak/flip.pdf}
\caption[Reflecting an element]
{\label{flip_shape}
An element that reflects across its spine during iterative refinement.
LR functions and least squares shape matching allow an element to reflect
across its spine, along its spine, or both.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation and Results}
\label{flowpak_implementation_and_results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



We design our containers and decorative elements in a vector graphics 
editor, and then use them as input to a C++ program that outputs final
placed elements in an SVG file.  We use the Clipper library~\cite{ClipperLib}
for calculation of LR functions and for testing polygon intersections 
during deformation and growth.
As a postprocess, we optionally smooth outlines and replace polygonal
paths with B\'{e}zier curves.
Finally, we apply colors and other treatments in an editor.

Our technique is fast except for the iterative refinement process,
which considers a large number of variations to the composition via
brute-force computation. On a computer with an Intel i7-4790K processor at 4.0 Ghz,
 15 iterations
of refinement on a packing of 50 elements takes about an hour.  Our
software is not intended to run interactively; still, we believe the
performance could be improved significantly through the use of more
sophisticated 2D geometric data structures \newtext{such as uniform grids or quadtrees}.

We tested our approach using a variety of container shapes, based mostly
on animals, and many different ornamental elements with varying amounts
of geometric complexity.
In Figure~\ref{fig_lion_unicorn}, we show two packings of a lion and a unicorn.
Each packing is generated with only a set of four elements.
The packings demonstrate that FLOWPAK is able to pack and deform
elements inside the containers.
In Figure~\ref{result_rhino},
we show a packing of a rhinoceros with simple teardrop elements
that demonstrates the variety we achieve in shape and curvature.
We use more complex leaf elements on the bear in 
Figure~\ref{result_bear_leaves}, and
adjust the tracing parameters to obtain shorter placed elements. 
We also process the placed elements to create a distressed look.

The packing of a cat in Figure~\ref{result_cat} demonstrates 
a symmetric packing with a fur contour. 
We only compute the left part and reflect the result.
The elements around the cheeks and the chin extend outward, not following the boundary, and creating the appearance of fur.

We experimented with two extensions to our pipeline, 
which could enhance its aesthetic value and flexibility.
First, in Figure~\ref{result_dog} we allow the user to draw 
\textit{fixed spines} in addition to fixed elements.  These fixed
spines act like pre-placed streamlines, which will be assigned blobs
and then elements.  However, they are not required to follow the
surrounding vector field, and are not shifted during the refinement
process.  Fixed spines are used in Figure~\ref{result_dog} for the 
flower petals in the torso and the paws.
Second, in Figure~\ref{result_bear_offset} we construct explicit new shapes
(drawn in brown)
to fill the negative space between placed elements (in black), 
by computing offset polygons from the negative space between elements. 
The result is a distinct and appealing style.  

Finally, we asked an artist to draw containers and decorative elements.
The result is the bird design shown in Figure~\ref{bird_square}.
The artist requested that different elements and densities be used in 
different container regions; the result has sparse ``Y'' elements in 
the breast and head, and denser ``O'' elements in the wings. The artist was pleased with the \newtext{result}.


%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/result_02.pdf} %RHINO
\caption[A packing of a rhinoceros]
{\label{result_rhino}
A packing of a rhinoceros.  Simple teardrop-shaped 
elements lead to variety in size and curvature.}
\bigskip
\includegraphics[width=1.0\textwidth]{figures/flowpak/bear_leaves.pdf} %BEAR LEAVES
\caption[A packing of a bear with leaf elements]
{\label{result_bear_leaves}
  A bear packing with leaf elements.  We manually add noise to the 
  elements in the output to create a distressed look.}
\end{figure}

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/cat.pdf}
\caption[A packing of a cat]
{A packing with a symmetric layout; we only compute the left half and reflect the result. The elements around the cheeks and the chin are not aligned to the boundary, creating a fur-like effect.}
\label{result_cat}
\end{figure}

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/dog_flower.pdf}
\caption[A packing of a dog]
{A packing of a dog. The fixed elements, shown as green
  shapes in the diagram, are copied as-is to the output; fixed spines,
  shown as green paths, force the placement of new elements at the given
  locations.}
\label{result_dog}
\end{figure}

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/bear_offset_space.pdf}
\caption[A packing of a bear with elements created from negative space]
{A packing of the same container as in Figure~\ref{result_bear_leaves}.
  We place longer and sparser elements and synthesize additional forms to
  fill negative space.}
\label{result_bear_offset}
\end{figure}

%FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\begin{figure}
\centering
\includegraphics[width=1.0\textwidth]{figures/flowpak/bird_square.pdf}
\caption[A packing of a bird]
{A packing of a bird, based on input provided by
  an artist.}
\label{bird_square}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{flowpak_conclusions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtext
{
We presented FLOWPAK, a method to create ornamental packings
in which the elements were oriented and deformed to give a sense of visual flow to the final composition.
Our implementation computed a vector field based on user strokes,
constructed streamlines that conform to the vector field, and placed an
element over each streamline. An iterative refinement process then
shifted and stretched the elements to improve the composition.
}

